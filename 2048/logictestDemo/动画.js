/**
 * 目标:
 *      打算在这个代码基础上加上块的移动效果，而不是数字的"突变" 
 * 
 * 回顾此次代码背景:
 *      分为两块： 游戏主体控制game、board对象
 *                game负责初始化、预处理用户的输入判断得出用户的移动方向
 *                将方向参数传给board，board负责棋盘里数字的变换；
 *                game拿到变换后的棋盘的数字，负责渲染修改对应node的innerText
 *      难点部分：
            move函数逻辑：
            [2, 0, 2, 0],  -- 4 0 0 0
            [0, 0, 2, 0],  -- 2 0 0 0 
            [0, 2, 0, 0],  -- 2 0 0 0
            [0, 2, 4, 4],  -- 2 8 0 0

            输入到输出的变换逻辑？
            origin -  init - merge - init
            0224    2240    4040    4400
            // init  将每行的所有零 到放到后面
            // merge 从行头开始遍历，遵循每次只产生一个效果值的原则（非连锁反应）
            //      2240 ---> 
                    if (row[j + 1] == row[j] && row[j] !== 0) 
                    newArr[i][j] += newArr[i][j + 1];
                    newArr[i][j + 1] = 0;
            所以：
                2240---> 4040---> 4400
            而连锁：
                4400->8000
                连锁仿佛是有一股力在往左边推，左边有堵墙 
                所以每次合并都是从墙头开始，且刚产生新值就会又被合并，直到(墙移到尾部)
                墙在当前元素没法合并的情况下往右移动
            非连锁：
                当前元素只会和力的反方向邻近元素发生反应，所以不会连锁
                22--> 40
        在非连锁下，从输入到输出经历如下变换：
            2 2 0 0         2 2 0 0          4 0 0 0            4 0 0 0 
            0 2 0 2   init  2 2 0 0  merge   4 0 0 0   init     4 0 0 0 
            2 0 2 0  -----> 2 2 0 0 -------> 4 0 0 0  ------>   4 0 0 0 
            2 2 4 0         2 2 4 0          4 0 4 0            4 4 0 0
            
        而对应不同方向移动，又是采取的矩阵变换再输出的方式
 * 
 * 本来的设想(灵感)：
 *      inspired by 假动作实现轮播
 *      我们知道最初的盘面，知道响应方向，知道最后合并后的样子
 *      能否也由最后的样子倒推到最初的来源，假动作还原一波过渡？
 * 
 * 
 *      要解决的问题：
 *      1、寻根：每粒棋子的来源--对象、位移
 *      2、移动过程的载体？
 *         旧node在消失的过程中，新node逐渐替换它
 *         去向:  旧node消失在了边框之外
 *                新node来到了旧node原址
 *         动画结束后，又一切恢复原样。
 *         照样通过数据改变dom的方式 updateview
 * 
 *  
 *      所以每层node下面多一层node。
 *      动画发生在init部分，所以在init部分在class？
 *      对应的函数部分是mergeArr里的moveinit()
 *      要在这里加动画吗?
 * 
 *      ===》
 *      试试在更新时
 *      使用css3动画可以代替js控制left、而且更灵活 
 *      而且：translate:100% 即表达了块的大小，无需再获取块大小
 *      缺点是： 怎么向css传参，或者定制化控制css移动距离
 *              移动一格 100% .1s
 * 
 *      每个格子无需严格追溯到源也可以实现动画效果？即移动一格
 */